# 缓存

[TOC]

缓存（Cache）

基于“**请求-应答**”模式的特点，可以大致分为**客户端缓存**和**服务器缓存**

## 服务器的缓存控制

一般的运行过程：

- 浏览器发现缓存没有数据，于是发送请求，向服务器获取资源
- 服务器响应请求，返回资源，同时标记资源的有效期
- 浏览器缓存资源，等待下次重用

服务器标记资源有效期使用的头字段：“**Cache-Control**”

- “**max-age**”：标记过期的时间
- "**no-store**"：**不允许缓存**，由于某些变化非常频繁的数据
- "**no-cache**"：**可以缓存**，但是使用之前必须去服务器验证是否过期，是否有最新的版本
- "**must-revalidate**"：如果缓存不过其就可以继续使用，但是过期了如果还想用就必须去服务器验证

## 客户端的缓存控制

浏览器也可以发送“**Cache-Control**”的请求头，也就是说“**请求-应答**”双方都可以用这个字段进行缓存，互相协商缓存的使用策略。

浏览器用“**Cache-Control**”做缓存控制只能使刷新数据，不能很好的利用缓存数据，又因为缓存会失效，使用前还必须去服务器验证是否是最新版。

既然需要验证，那么可以发送两次请求去确认，但是这样网络成本太高，所以HTTP协议定义了一些列“**If**”开头的“**条件请求**”字段，专门用来检查验证资源是否过期，把两个请求才能完成的工作合并在一个请求里做。而且，验证的责任也是较给服务器，浏览器只需“坐享其成”

条件请求字段：

- “**If-Modified-Since**”和“**If-Nome-Match**”
  - 第一次的**响应报文**预先提供“**Last-Modifed**”和“**ETag**”，然后第二次请求时就可以带上缓存的原始值，验证资源是否使最新的。
  - 如果资源没有变，服务器就回应一个“**304 Not Modified**”，标识缓存亦然有效，浏览器就更新以下有效期，然后使用缓存

“**ETag**”是“**实体标签**”（Entity Tag）的缩写，是**资源的一个唯一标识**，主要是用来解决时间**无法准确区分文件变化的问题**。

使用"**ETag**"可以**精确的**识别资源的变动情况，让浏览器能够更有效地利用缓存

## 缓存代理服务

缓存代理：既是客户端，有时服务器

”**Cache-Control**“为了限制代理服务器的功能，增加的新属性

- ”**private**“：只能在客户端保存，不能放在代理上
- ”**public**“：缓存完全开放，谁都可以存，谁都可以用
- ”**s-maxage**“：限定在代理服务器上能够存多久（客户端还是max-age）

**区别属性：**

- ”**must-revalidate**“：缓存过期必须回源服务器验证

- ”**proxy-revalidate**“：代理的缓存过期后必须验证，客户端不必回源，只验证到代理这个环节就行了

  

