# HTTPS

[TOC]

HTTP是最开始是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以HTTP一直保持着明文传输数据的特性。这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间可能该有个中间人，你们在通信过程中的一切内容都在中间人的掌握中

![](I:\myFuture\桌面资料\面试\学习图片\中间人攻击.png)

使用HTTP传输的内容很容易被中间人窃取、伪造和篡改，通常我们把这种攻击方式称为中间人攻击

具体来说，在将HTTP数据交给TCP层之后，数据会经过电脑、WIFI路由器、运营商和目标服务器，在这中间的每个环节，数据都有可能被窃取或者篡改。

## HTTP协议栈引入安全层

![](I:\myFuture\桌面资料\面试\学习图片\HTTPVSHTTPS.png)

HTTPS并非是一个新的协议，通常HTTP直接和TCP通信，HTTPS则先和安全层通信，然后安全层再和TCP层通信。也就是说HTTPS所有安全核心都在安全层，并不会影响上面的HTTP协议，也不会影响到下面的TCP/IP

安全层的主要职责：

- 对发起HTTP请求的数据进行加密操作
- 对接收HTTP的内容进行解密操作

## 第一版：使用对称加密

对称加密：加密和解密都使用相同的密钥

![](I:\myFuture\桌面资料\面试\学习图片\使用对称加密实现HTTPS.png)

具体过程：

- 浏览器发送它所支持的加密套件列表和一个随机数client-random，这里的加密套件是指加密的方法，加密套件列表是指浏览器能支持多少种加密方法列表
- 服务器会从加密套件列表中选取一个加密套件，然后生成一个随机数Server-random，并将service-random和加密套件列表返回给浏览器
- 浏览器和服务器分别返回确认消息

浏览器和服务器都有相同的client-random和service-random，然后再使用相同的方法将client-random和service-random混合起来生成一个master secret，有个master secret和加密套件之后，双方可以进行数据的加密传输了。

但是client-random和service-random都是明文的，意味着黑客也能拿到协商的加密套件和双方的随机数，由于随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥伪造和篡改数据了

## 第二版：使用非对称加密

非对称加密：有A、B两把密钥，如果你用A密钥加密，那么只能使用B密钥解密；反过来，如果用B密钥加密，那么只能用A密钥解密

在HTTPS中，服务器会将其中一个密钥通过明文的形似发送给浏览器，我们把这个密钥称为公钥，服务器自己留下的那个密钥称为私钥。所以：公钥是每个人都能获取到的，而私钥只有服务器才能知道，不对任何人公开

![](I:\myFuture\桌面资料\面试\学习图片\非对称加密实现HTTPS.png)

过程：

- 浏览器发送加密套件列表给服务器
- 服务器选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器需要有用于浏览器加密的公钥和服务器解密HTTP数据的私钥，由于公钥是要给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器
- 最后就是浏览器和服务器返回确认消息

这样浏览器就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用公钥来解密数据。由于公钥加密只有私钥才能解密，所以即时黑客截获了数据和公钥，他也不发使用公钥来解密数据。

因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的，但是缺点：

- 非对称加密的效率太低
- 无法保证服务器发送给浏览器的数据安全。虽然浏览器可以使用公钥来加密，但是服务器端只能采用私钥加密，私钥加密只有公钥能解密，但黑客就可以获取到公钥，这样就不能保证服务器端数据安全了

## 第三版：对称机密和非对称加密搭配使用

结合以上两种方法：**在传输数据阶段使用对称加密，但是对称加密的密钥我们采用非对称加密传输**

![](I:\myFuture\桌面资料\面试\学习图片\混合实现HTTPS.png)

过程：

- 浏览器向服务器发送对称加密套件列表、非对称加密列表和随机数client-random
- 服务器保存client-random，选择对称加密和非对称加密套件，然后生成随机数service-random，向浏览器发送选择的加密套件、service-random和公钥
- 浏览器保存公钥，并利用client-random和service-random计算出pre-master，然后利用公钥对pre-master加密，并向服务器发送加密后的数据
- 服务器拿出自己的私钥，解密出pre-master数据，并返回确认信息

这样，浏览器和服务器就有了共同的client-random、service-random和pre-master，然后服务器和浏览器会使用这三组随机数生成“**对称密钥**”，因为服务器和浏览器使用同一套方法来生成密钥，所以最终生成的密钥也是相同的

有了对称加密的密钥后，双方就可以使用对称加密的方式来传输数据了。

“**注意**”：因为pre-master是经过公钥加密之后传输的，所以黑客无法获取到pre-master，也就无法生成密钥，也就保证饿了黑客无法破解传输过程中的数据了

## 第四版：添加数字证书

通过对称加密和非对称混合方式，可以实现数据的加密传输，但是这种方式依然存在问题，比如，我们打开某个网站，但是黑客通过”**DNS劫持**“将网站的IP地址换成了黑客的IP地址，这样我们访问的就是黑客的服务器了，黑客就可以在自己的服务器上实现公钥和私钥，而这对浏览器来说，是完全不知道现在访问的是黑客的站点

所以，需要服务器向浏览器提供证明”**我就是我**“

这个时候需要一个**权威机构CA**，并通过这个权威机构颁发一个证书”**数字证书**“

对于浏览器来说，数字证书的作用：

- 通过数字证书向浏览器证明服务器身份
- 数字证书包含了服务器的公钥

![](I:\myFuture\桌面资料\面试\学习图片\完整的HTTPS流程.png)

相对于第三版，变化：

- 服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥包含在数字证书中
- 浏览器端多个一个证书验证的操作，验证了证书之后，才能继续后续流程

通过了引用数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，由于证书是没有办法伪造的，所以无法欺骗用户

### 如何申请数字证书

- A网站需要准备一套私钥和公钥，私钥留着自己使用
- 然后A向CA机构提交公钥、公司、站点等信息并等待认证，这个过程可能是收费的
- CA通过线上、线下等多种渠道验证A提供信息的真实姓
- 如信息审核通过，CA会向A签发认证的数字证书，里面包含了公钥、组织信息、CA信息、有效时间、证书序列号等，这些都是明文的，同时还包括一个CA生成的签名

数字签名：CA使用**Hash函数**来计算A提交的明文信息，并得出**信息摘要**，然后CA再使用它的私钥对信息摘要进行加密，**加密后的密文就是CA颁发给A的数字签名**（相当于一个有认证的章）

### 浏览器如何验证数字证书

浏览器读取证书中相关的明文信息，采用CA签名时相同的Hash函数来计算并得到信息摘要A

然后再利用对应的CA的公钥解密签名数据，得到信息摘要B

对比信息摘要A和信息摘要B，如果一致，则可以确认证书是合法的，除此之外，浏览器还会验证证书相关的域名信息、有效时间等信息。

### 申请和使用注意点

- 申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握
- 数字证书最核心的是CA使用它的私钥生成的数字签名
- 内置CA对应的证书称为根证书，根证书是最权威的机构，他们能为自己签名，我们把这称为自签名证书