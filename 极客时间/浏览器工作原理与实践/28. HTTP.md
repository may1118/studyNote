# HTTP1

[TOC]

## HTTP/0.9

*实际没有0.9这样一个版本信息，而是后面加上的*

- 只支持GET请求
- 没有请求头和请求体
- 服务器也没有响应头信息
- 只允许ASCII字符流传输信息

总的来说比较简单，而且那个时候网页传输的内容几乎是纯文本，也没有考虑到其他形式的内容。

## HTTP/1.0

因为浏览器展示的不仅仅是HTML文件了，还包括JavaScript、CSS、图片、音频、视频等不同类型的文件。因此，需要保证HTTP协议“**支持多种类型的文件下载**”，而且文件格式不仅仅局限于ASCII编码

### 请求/响应头——保证多种类型文件的下载

请求头和响应头，都是以Key-Value形式保存，发送/响应的时候带上相应的头信息

利用头信息来告诉相关这是什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码等。

```http
请求——响应
accept	——	content-type 类型
accept-encoding	——	content-encoding 压缩
accept-charset	——	content-type 编码
accept-language	——	content-language 语言
```

- 引入了状态码
- Cache机制
- 用户代理

## HTTP/1.1

- 长连接：一个TCP连接上可以传输多个HTTP请求，只要浏览器或者服务器没有明确断开连接，那么该TCP连接会一致保持（但是也造成了一个“**队头阻塞**”）
- 增加了Host字段，保证服务器可以根据不同的Host值做不同的处理
- 对动态生成的内容支持
- 客户端Cookie、安全机制

## HTTP/2

### HTTP/1.1存在的问题

- 对带宽利用率不理想
  - TCP的慢启动
  - 同时开启多条TCP连接，这些连接会竞争固定带宽
  - 队头阻塞问题：虽然能够共用一个TCP管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态

### HTTP/2的多路复用

因为TCP的慢启动我们是无法避免的，所以我们可以只使用一个域名，只是用一个TCP长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个TCP连接竞争带宽带来的问题

对于队头阻塞，HTTP/2采用资源并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器

所以，HTTP/2的解决方案可以总结为：一个域名只使用一个TCP长连接和消除队头阻塞问题

#### 总的处理过程

![](I:\myFuture\桌面资料\面试\学习图片\HTTP2协议栈.png)

- 浏览器准备好请求数据，包括请求行、请求头等信息，如果是POST，那么还有请求体
- 这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求ID编号的帧，通过协议栈将这些帧发送给服务器
- 服务器接收到所有帧之后，会将所有相同ID的帧合并为一条完整的请求信息
- 然后服务器处理该条请求，并行处理的响应行、响应头和响应体分别发送至二进制分帧层
- 同样，二进制分帧层会将这些相应数据转换为一个个带有请求ID编号的帧，经过协议栈发送给浏览器
- 浏览器接收到响应帧之后，会根据ID编号将帧的数据提交给对应的请求

可以看出，通过二进制分帧层，就实现了HTTP的多路复用技术。

### HTTP/2其他特性

- 设置请求优先级
- 服务器推送
- 头部压缩

## HTTP/3

### TCP的缺点

#### TCP的队头阻塞

由于单个数据包的丢失而造成的阻塞称为TCP的队头阻塞

因为HTTP/2之开启的一个TCP连接，那么只要由丢包，那么整个传输速率都会收到影响，而HTTP/1.1支持多个TCP连接，如果一个TCP连接发生发生了TCP队头阻塞，但是其他的连接还是可以继续传输数据。

随着丢包率的增加，HTTP/2的传输效率只会越来越差。测试表明，当系统丢包率达到2%的时候，HTTP/1.1的传输效率反而比HTTP/2表现更好

#### TCP连接的延时

网络时延：RTT

![](I:\myFuture\桌面资料\面试\学习图片\网络时延.png)

建立TCP连接，需要花费多少RTT？

HTTP/1和HTTP/2都是使用TCP协议传输，而如果使用HTTPS的话，还需要使用TLS协议进行安全传输，而使用TLS也需要一个握手过程

1. 建立TCP连接，需要三次握手来确认，需要消耗1.5个RTT
2. TLS两个版本TLS1.2和TLS1.3，每个版本所花的时间不同，大致需要1-2个RTT

总的来说，在传输数据之前需要3-4个RTT。RTT和浏览器和服务器的物理距离有关，如果较近，那个1RTT ≈ 10ms，距离较远1RTT ≈ 100ms

#### TCP协议僵化

通过改进TCP协议来解决问题非常困难

“**中间设备僵化**”：

- 互联网是由多个网络互联的网状结构，保证互联网的各处搭建的设备叫做中间设备。
- 每个中间设备都有自己的目的，例如：路由器、防火墙、NAT、交换机等。
- 通常依赖一些很少升级的软件，这些软件使用了大量的TCP特性，设置之后就很少更新了，所以如果我们需要升级TCP协议，**但是当新协议的数据包经过这些中间设备时，他们不可能理解包的内容，于是这些数据就会被丢弃掉**，这就是中间设备僵化

- 操作系统也是导师TCP协议僵化的另外一个原因。因为TCP协议都是通过操作系统内核是实现的，应用程序只能使用不能修改。

### QUIC协议

既然修改TCP协议不太显示，那么我们可以发明一个TCP和UDP之外新的传输协议，但是也面临着和修改TCP一样的挑战，因为中间设备的僵化，这些设备只认识TCP和UDP协议，如果采用了新的协议，新协议在这些设备同样不能被很好的支持。

因此，HTTP/3选择了一个折中的方法——UDP协议，**基于UDP实现了类型于TCP的多路数据流、传输可靠性等功能**，我们称为QUIC协议

![](I:\myFuture\桌面资料\面试\学习图片\HTTP2和HTTP3协议栈.png)

HTTP/3中的QUIC结合了一下几点功能：

- 实现了类似TCP的流量控制、传输可靠性：QUIC在UDP基础上增加了一层来保证数据可靠性传输。
- 集成了TLS加密功能：使用的是TLS1.3
- 实现了HTTP/2的多路复用功能
- 实现了快速握手功能：UDP特性

### HTTP/3挑战

- 服务器和浏览器端都没有对HTTP/3提供比较完整的支持
- HTTP/3部署存在较大问题
- 中间设备僵化的问题