# 宏任务和微任务

[TOC]

## 宏任务

宏任务主要包括：

- 渲染事件
  - 解析DOM
  - 计算布局
  - 绘制
- 用户交互事件
  - 鼠标点击
  - 滚动页面
  - 放大缩小
- JavaScript脚本执行事件
- 网络请求完成、I/O事件

为了协调这些任务有条不紊的在主线程上执行，页面进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，例如：**延迟执行队列**和**普通消息队列**。然后主线程采用一个for循环，不断地从这些任务队列中取出任务并执行任务。我们把这些消息队列中地任务称为**宏任务**。

### 大致执行流程

- 先从多个消息队列中**取出**最老地**任务**，这个任务称为oldestTask
- 然后循环系统**记录开始执行地时间**，并把这个oldestTask**设置为当前正在执行地任务**
- 当前任务执行完成之后，**删除**当前正在执行地任务，并从对应地消息队列中删除这个oldestTask
- 最后统计执行完成地时长等信息

### 缺点

随时可能被添加到消息队列，而且添加事件由系统操作地，JavaScript代码不能准确掌控任务要添加到队列中地位置，控制不了任务在消息队列中地位置，所以**很难控制开始执行任务地时间**

```js
function timerCallbacks(){
    console.log(2);
}
function tinerCallback(){
    console.log(1);
    setTimeout(timerCallback2,0);
}
setTimeout(timerCallback,0);
```

目的是想通过setTimeout来设置两个回调任务，并让他们按照前后顺序来执行，中间也不要插入其他任务，**因为如果两个任务中间插入了其他地任务**，就很有可能会影响到第二个定时器地执行时间了。

但是实际情况是我们不能控制的，因为可能在调用setTimeout来设置回调任务的间隙，消息队列就有可能被插入很多系统级的任务。

所以说：宏任务的时间粒度比较大，执行的时间间隔时不能精确控制的，对一些高实时性的需求就不太符合了。例如：监听DOM变化的需求

## 微任务

### 异步回调方式

- 把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数
- 执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这同时都是以微任务形式提现的

So：微任务就是一个需要异步执行的函数，执行时机是在**主函数执行结束之后、当前宏任务结束之前**

### V8引擎解析执行

执行一段JavaScript脚本的时候，V8会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8引擎也会在内部创建一个“**微任务队列**”。即：存放微任务的

但是仅供V8引擎内部使用，所以无法通过JavaScript直接访问。

### 产生微任务

- MutationObserver监控某个DOM节点，然后再通过JavaScript来修改这个节点，或者为这个节点添加、删除部分子节点
- Promise，当调用Promise.resolve()或者Promise.reject()

### 执行微任务

通常情况下：当前宏任务中的JavaScript快执行完成时，也就是JavaScript引擎**准备退出全局执行上下文并清空调用栈的时候**，JavaScript引擎会**检查**全局执行上下文中的**微任务队列**，然后**按照顺序执行**队列中的微任务。

如果在执行微任务的过程中，产生了新的微任务，同样也会将该微任务添加到微任务队列中，V8引擎一直循环执行微任务队列中的任务，**直到队列为空才算执行结束**。也就是说在**执行微任务过程中产生的新的微任务并不会推知道下个宏任务中执行，而是在当前宏任务中继续执行**。

![](I:\myFuture\桌面资料\面试\学习图片\微任务和宏任务执行流程示意图.png)

在执行有一个ParseHTML宏任务中，遇到了JavaScript脚本，那么就暂停解析流程，进入到JavaScript的执行流程

在JavaScript脚本的后续执行过程中，分别通过promise和removeChild创建两个微任务，并被添加到微任务列表中。接着JavaScript执行结束，准备退出全局执行上下文，这时候就到了**检查点（执行微任务的时间点）**了，JavaScript引起会检查微任务列表，发现微任务列表中有微任务，那么接下来，一次执行两个微任务，等微任务队列清空之后，就退出全局执行上下文。

## 结论

- 微任务和宏任务都是绑定的，每个宏任务执行时，会创建自己的微任务队列
- 微任务的执行时长会影响到当前宏任务的时长。

- 一个宏任务中，分别创建一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。

## 监听DOM变化方法演变

“**MutationObserver**”是用来监听DOM变化的一套方案。

因为需要监听DOM变化并即时做出响应

虽然可以使用“**轮询检测**”，例如：setTimeout、setInterval来定时检测DOM是否有改变

“**缺点：**”

- 如果设置间隔时间过长，DOM变化响应不够即时
- 时间过短，又会浪费很多无用的工作量去检查DOM，会让页面变得低效

DOM4开始，推荐使用MutationObserver，其API可以监视DOM的变化，包括属性的变化、节点的增减、内容的变化等等

### 改进

采用异步调用，可以不用在每次DOM变化都触发异步调用，而是等多次DOM变化后，“**一次触发异步调用**”，并且还会使用一个数据结构来记录这期间所有的DOM变化。其实频繁的操作DOM，也不会对想能造成太大的影响。

通过异步调用和减少触发次数来缓解性能问题，那么如果做到即时性呢？

如果采用setTimeout创建空任务来触发回调的话，那么实时性会大打折扣，因为可能会插入其他的事件，从而影响到响应的实时性。

这时候，“**微任务**”就可以解决，在每次DOM节点发生变化的时候，渲染引擎会将变化记录封装成为微任务，并将微任务添加进当前的微任务列表中。

### 总结

MutationObserver采用了“**异步+微任务**”的策略

- 通过**异步**解决了**同步操作的性能问题**
- 通过**微任务**解决了**实时性的问题**