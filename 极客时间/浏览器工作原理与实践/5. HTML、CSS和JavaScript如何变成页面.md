# HTML、CSS和JavaScript如何变成页面

[TOC]

主要是浏览器进程的“**渲染模块**”

由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多自阶段，输入的HTML经过这些子阶段，最后输出像素。我们把这样的一个处理流程叫做“**渲染流水线**”

## 构建DOM树

为什么要构建DOM树呢？**因为浏览器无法直接理解和使用HTML，所以需要将HTML转换为浏览器能够理解的结果——DOM树**

![](I:\myFuture\桌面资料\面试\学习图片\DOM树构建过程.png)

如果需要获取DOM树

```js
console.log(document);
```

看到的document就是DOM结构，发现和HTML内容几乎一样，但是和HTML不同的是，DOM是保存在内存中的树状结构，**可以通过JavaScript来查询或修改其内容**。

## 样式计算

### 把CSS转换为浏览器能够理解的结构

CSS的来源：

- 通过link引用的CSS文件
- `<style>`标记内的CSS
- 元素的style属性内嵌的CSS

当渲染引擎接收到CSS文本时，会执行一个转换操作，将CSS文本转换为浏览器可以理解的结构——"**styleSheets**"

```js
document.styleSheets
```

### 转换样式表中的属性值，使其标准化

**需要将所有值转换为渲染引擎容易理解、标准化的计算值**，这个过程就是属性值标准化

![](I:\myFuture\桌面资料\面试\学习图片\标准化属性值.png)

### 计算出DOM树种每个节点的具体样式

涉及到CSS的继承规则和层叠规则

- !important
- 内联样式
- ID 选择器#app
- 伪类:hover
- 属性选择器[type="radio"] 
- 类选择器.className 
- 类型选择器h1
- 伪元素::after
- 通用选择器(*)

内联样式1000 > id选择器100 > 类选择器10 > 元素选择器1

## 布局阶段

“计算出DOM树种**可见元素**的几何位置”

### 创建布局树（Layout Tree）

![](I:\myFuture\桌面资料\面试\学习图片\布局树.png)

DOM树种所有不可见的节点都没有包含在布局树中（例如：display:none）

为了构建布局树，浏览器大致完成：

- 遍历DOM树种所有可见节点，并把这些节点加到布局中
- 不可见的节点会被布局忽略掉，例如：head标签下面的全部内容，display：none的内容

### 布局计算

计算布局树节点的坐标位置，并将这些信息保存在布局树中

### 分层

因为页面中有很多复杂的效果，如一些复杂的3D变换、页面滚动，或者使用z-index做z轴排序等，为了更加方便地实现这些效果，**渲染引擎还需要为特定地节点生成专用地图层，并生成以可对应地图层树（Layer Tree）**

现在知道了浏览器的页面实际上被分成了很多图层，这些图层 叠加之后合成了最终的页面。

![](I:\myFuture\桌面资料\面试\学习图片\布局树和图层树.png)

通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就丛书父节点的图层。例如：span标签没有专属图层，那么他们就从属他们的父节点图层，但不管怎么样，最终每一个节点都会直接或者间接地属于一个层。

如何才能被单独提升为一个图层

- 用用层叠上下文属性的元素会被提升为单独的一层
  - z-index
  - position
  - filter
  - opacity
- 需要剪裁（clip）的地方
  - 如果内容超出了规定，就产生了剪裁，渲染引擎会把裁剪文字内容的一部分显示在指定内容（溢出内容看不到）
- 滚动条

### 图层绘制

渲染引擎实现图层的绘制会把一个图层拆分为很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表

### 栅格化（raster）操作

绘制列表只是用来**记录绘制顺序和绘制指令的列表**，而实际上绘制操作是由渲染引擎中的合成线程来完成的。

图层的绘制列表准备好之后，主线程会把该绘制列表**提交**（commit）结合成线程

通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做“**视口（viewpoint）**”

在这种情况下，由的图层可以很大，比如有的页面你使用滚动条要滚动很久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制所有图层的化，就会产生太大的开销，而且没有必要。

所以，基于这个原因，**合成线程会将图层划分为图块（tile）**

![](I:\myFuture\桌面资料\面试\学习图片\图层被划分为块图.png)

然后，合成线程会按照视口附近的图块来优先生成位图，实际生成图的操作是由栅格化来执行的。所谓栅格化，**是指块图转换为位图。**

而块图是栅格化执行的最小单位。

通常，栅格化过程都会使用GPU来加速生成，使用GPU生成位图的过程叫快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。

### 合并和显示

一旦所有图块都被光栅化，合成线程就会生成一会绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

## 总结

从HTML到DOM、样式计算、布局、图层、绘制、光栅化、合并和显示

- 渲染进程将HTML内容转换为能读懂的**DOM树**结构
- 渲染引擎将CSS样式表转化位可以理解的**styleSheet**，计算DOM节点的样式
- 创建**布局树**，并计算元素的布局信息
- 对布局树进行分层，并生成**分层树**
- 为每个图层生成**绘制列表**，并将其提交到合成线程
- 合成线程将图层分成**图块**，并在**光栅化线程池**中将图块转换成位图
- 合成线程发送绘制图块命令**DrawQuad**给浏览器流程
- 浏览器流程根据DrawQuad消息**生成页面**，并**显示**到显示器上

## 相关概念

### 重排（更新了元素的几何属性）

![](I:\myFuture\桌面资料\面试\学习图片\重排.png)

通过JavaScript或者CSS修改元素的几何位置属性，例如：改变元素的宽度、高度等

重排需要更新完整的渲染流水线，所以开销也是最大的

### 重绘（更新元素的绘制属性）

![](I:\myFuture\桌面资料\面试\学习图片\重绘.png)

因为并没有引起几何位置的改变，所以直接进入了绘制阶段，所以执行之后的一系列子阶段。

重绘省去了布局和分层阶段，所以执行效率比重排操作高一点

### 直接合成阶段

![](I:\myFuture\桌面资料\面试\学习图片\直接合成.png)

例如：使用CSS的transform来实现动画效果，可以避开重排和重绘阶段，直接在非主线程是执行合成操作，这样的效率是最高的，因为没有占用主线程的资源，另外也避开了布局和绘制两个自阶段，所以：相对于重绘和重排，合成能大大提升绘制效率。