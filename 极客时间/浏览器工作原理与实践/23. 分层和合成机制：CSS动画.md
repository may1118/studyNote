# 分层和合成机制：CSS动画

[TOC]

在布局树生成之后，还需要经历分层、绘制、合成、显示等阶段才能显示出页面

*主要介绍渲染引擎分层和合成机制*

## 显示器是怎么显示图像的

每个显示器都有固定的刷新频率，通常是60HZ，也就是每秒更新60张图片，更新的图片是来自于显卡中的一个叫“**前缓冲区**”的地方，显示器所做的任务很简单，**就是每秒固定读取60次前缓冲区中的图像，并将读取的图像显示到显示器上**。

### 显卡

显卡的职责就是**合成新的图像**，并将图像保存到“**后缓冲区**”中，一旦显卡把合成的图像写到后缓冲区中，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率一致。但是有得时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。

| 前缓冲区     | 后缓冲区     |
| ------------ | ------------ |
| 读取显示图片 | 保存合成图片 |

### 帧VS帧率

*实际场景：*

当通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以会感觉到有动画效果，因为在滚动或者缩放操作时，“**渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区**”

大多数屏幕的更新频率时60次/秒，这也就意味着在正常情况下需要实现流畅的动画效果，渲染引擎需要每秒更新60张图片到显卡的后缓冲区。

渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如：在滚动过程中1秒更新了60帧，那么帧率就是69Hz

------

由于用户很用以观察到那些丢失帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会很容易感受到卡顿，这会给用户造成非常不好的印象。

Chrome解决方案：对浏览器渲染方式做了大量的工作，比较好的就是引入了“**分层和合成机制**”。

## 如何生成一帧图像

任意一帧的生成方式有：重排、重绘和合成

| 方式 | 过程                                                         |
| :--- | ------------------------------------------------------------ |
| 重排 | 需要重新根据CSSOM和DOM计算布局树                             |
| 重绘 | 没有重新布局阶段，但是还是需要重新计算绘制信息，并触发绘制操作之后的一系列操作 |
| 合成 | 并不需要触发布局和绘制，如果采用了GPU，那么合成效率更高（只需要显卡进行合成） |

Chrome中合成技术：分层、分块和合成

## 分层和合成机制

通常页面的组成是非常复杂的，有的页面里要实现一些复杂的动画效果，比如点击菜单时弹出菜单的动画特效，滚动鼠标滚轮的动画特效，还有一些炫酷的3D动画特效。如果没有分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化，都会触发重排或者重机制，这种“**牵一发而动全身**”的绘制策略会严重影响页面的渲染效率。


### 为什么引入

分层：可以想象成一张网页由很多图片叠加在一起的，每个图片就是一个图层

合成：Chrome合成器最终将这些图层合成了用户显示页面的图片

*实际例子：*

一个页面划分成了两个图层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者Alpha渐变，这个时候，合成器只需要将两个图层进行响应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。

### 怎么实现

在Chrome渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为“**分层树（Layer Tree）**”，分层树时渲染流水线后续流程的基础结构。

分层树中的每个节点都对应着一个图层，下一步的**绘制阶段**就依赖于层树中的节点。

“**绘制阶段**”：并不是真正的绘制出图片，而**是将绘制指令组合成一个列表**

“**光栅化阶段**”：按照绘制列表中的指令**生成图片**。**每一个图层都对应着一张图片**，合成线程有了这些图片之后，就会将这些图片合成“一张”图片，最终将生成地图片会发到**后缓冲区**

“**注意：**”

**合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程的执行**。这也就是为什么主线程卡住了，但是CSS动画依然能执行的原因。

## 分块

分层从宏观上提升效率，那么分块则从微观上提升了渲染效率。

### 原因

通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。

因此，合成线程通常将每个图层分割为大小固定的图块，然后优先绘制靠近时候的图块，这样就可以大大加速页面的显示速度。不过有的时候，即时只绘制那些优先级最高的图块，也要耗费不小的时间，因为设计到一个很关键的因素——“**纹理上传**”，这是因为从计算机内存上传到GPU内存的操作会比较慢

### 优化策略

在首次合成图块的时候使用一个低分辨率的图片。首先显示的时候，将这个低分辨率的图片显示出来，然后继续合成绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。

## 利用分层优化代码

可以使用`will-change`来优化

```css
.box{
    will-change: transform,opacity;
}
```

提前告诉渲染引擎box元素**将要做几何变化和透明变换操作**，这时候渲染引擎会将该元素**单独实现一帧**，等这些变换发生时，渲染引擎会通过**合成线程直接去处理变换**，这些变换没有直接涉及到主线程，这样就大大提升了效率。

这也就是CSS动画比JavaScript动画高效的原因。

“**缺点:**”

需要占用内存，所以需要适当使用