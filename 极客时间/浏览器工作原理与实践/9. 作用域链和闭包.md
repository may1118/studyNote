# 作用域链和闭包

[TOC]

## 作用域链

需要提前了解的概念：

- 调用栈
- 执行上下文
- 词法环境
- 变量环境
- ......

其实在每个执行上下文的变量环境中，都包含了一个**外部引用**，用来指向外部的执行上下文，我们把这个外部引用成为“**outer**”

![](I:\myFuture\桌面资料\面试\学习图片\调用栈.png)

图中可以看出，bar函数和foo函数的outer都指向全局上下文，这也意味着如果在bar函数或者foo函数中使用了外部变量，那么JavaScript引擎会去全局执行上下文中查找。我们把这个查找的链条称为**作用域链**。

## 词法作用域

词法作用域：作用域是由代码中“**函数声明的位置**”来决定的，所以词法作用域是“**静态作用域**”，通过它就能够预测代码执行过程中如何查找标识符。

> 词法作用域是代码阶段就决定好的，和函数怎么调用没有关系

## 块级作用域中的变量查找

使用let/const申明的变量会存放到“**词法环境**”中，查找的顺序也是

> 词法环境-->变量环境-->上级作用域

## 闭包

```js
function foo(){
    var myName = '极客时间';
    let test1 = 1;
    const test2 = 2;
    var innerBar = {
        getName:function(){
            console.log(test1);
            return myName;
        },
        setName:function(newName){
            myName = newName;
        }
    }
    return innerBar;
}
var bar = foo();
bar.setName('极客邦');
console.log(bar.getName());
```

![](I:\myFuture\桌面资料\面试\学习图片\执行到return bar时候的调用栈.png)

根据词法作用域的规则，**内部函数getName和setName总是可以访问他们的外部函数foo中的变量**，所以当innerBar对象返回给全局变量bar时，虽然foo函数已经执行结束，但是getName和setName函数依然可以使用foo函数中的变量myName和test1。所以当foo函数执行完成之后，其整个调用栈的状态如下图所示：

![](I:\myFuture\桌面资料\面试\学习图片\闭包产生的过程.png)

**定义**：**在JavaScript中，根据词法作用域的规则，内部函数总是可以访问外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即时该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们把这些变量的集合成为闭包。**比如外部函数foo，那么这些变量的集合就成为foo函数的闭包。

> 由于在JavaScript语言中，**只有函数内部地子函数才能读取局部变量**，因此可以把闭包简单理解成“**定义在一个函数内部地函数**”。

## 闭包回收

通常，引用闭包的函数是一个全局变量，那么闭包会一致存在知道页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

**注意：**如果该闭包会一致使用，那么它可以作为全局变量而存在；但是如果使用频率不高，而且占用内存呢又比较大的话，那就尽量让它成为一个局部变量。