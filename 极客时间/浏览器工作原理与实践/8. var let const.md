# var let const

[TOC]

由于`JavaScript`存在变量**提升特性**，从而导致了很多与直觉不符的代码，这也是JavaScript的一个重要设计缺陷

## 作用域

作用域：定义变量的区域，该位置决定了变量的生命周期。通俗的理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。

在ES6之前，ES的作用域只有两种：

- **全局作用域**：任何地方都可以访问，其生命周期伴随着页面的生命周期
- **函数作用域**：函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部访问。函数执行结束后，函数内部的变量会被销毁。

**块级作用域：**使用一对大括号包裹的一段代码，例如：函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。**代码块内部的变量在代码块外部是访问不到的，并且等该代码中的代码执行完成之后，代码块中定义的变量会被销毁**

## 变量提升带来的问题

- 变量容易在不被察觉的情况下被覆盖掉
- 本应该销毁的变量没有被销毁

## ES6解决

引入了let/const

- let声明的变量可以被修改
- const申明的变量其值是不可以被修改

## JavaScript是如何支持块级作用域的

**执行上下文**

```js
function foo(){
    var a = 1;
    let b = 2;
    {
        let b = 3;
        var c = 4;
        let d = 5;
        console.log(a);
        console.log(b);
    }
    console.log(b);
    console.log(c);
    console.log(d);
}
foo()
```

- 编译并创建执行上下文

  ![](I:\myFuture\桌面资料\面试\学习图片\刚执行时foo函数的执行上下文.png)

- 结论：

  - 函数内部通过var声明的变量，在编译阶段全都存放到**变量环境**里面
  - 通过let声明的变量，在编译阶段会被存放到**词法环境**
  - 在函数内部的作用域内部，通过let声明的变量并没有被存放到词法环境中

- 继续执行代码

  ![](I:\myFuture\桌面资料\面试\学习图片\执行foo函数内部作用域时的执行上下文.png)

- console.log(a)的过程

  ![](I:\myFuture\桌面资料\面试\学习图片\变量查找过程.png)

- 作用域块执行结束后，其内部定义的变量会从词法环境的栈顶弹出

  ![](I:\myFuture\桌面资料\面试\学习图片\作用域执行完成示意图.png)