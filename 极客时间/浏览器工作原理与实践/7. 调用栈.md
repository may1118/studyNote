# 调用栈

[TOC]

## 编译并创建执行上下文

1. 当JavaScript执行**全局代码**的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份
2. 当调用一个**函数**的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁
3. 当使用**eval函数**的时候，eval的代码也会被编译，并创建执行上下文

调用栈就是用来**管理函数调用**关系的一种**数据结构**。

## 函数调用

```js
var	a = 2 
function add(){ 
    var	b =	10 
    return a+b; 
}
add();
```

函数调用过程：

在执行到函数“**add()**”之前，JavaScript引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量

![](I:\myFuture\桌面资料\面试\学习图片\全局执行上下文.png)

可以看到，代码中全局变量和函数都保存在全局上下文的变量环境中。

执行上下文准备好之后，便开始执行全局代码，当执行到add这儿时，JavaScript判断这是一个**函数调用**，那么执行以下操作：

- 从全局执行上下文中，取出add函数代码
- 对add函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码
- 执行代码，输出结果

![](I:\myFuture\桌面资料\面试\学习图片\函数调用过程.png)

## 管理执行上下文

数据结构：栈，后进先出

## JavaScript的调用栈

在执行上下文创建好后，JavaScript引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈成为**执行上下文栈**，又称**调用栈**

```js
var a = 2;
function add(b,c){
    return b+c;
}
function addAll(b,c){
    var d = 10;
    result = add(b,c);
    return a + result + d;
}
addAll(3,6);
```

“**执行过程：**”

1. 创建全局上下文，并将其压入栈底
   1. a 函数add 和 函数addAll都保存到了全局上下文的环境对象中
   2. 压入调用栈后，JavaScript引擎开始执行全局代码。首先会执行a = 2的赋值操作，执行该语句会将全局上下文变量中a的值设置为2
2. 调用addAll函数
   1. JavaScript引擎会编译该函数，并为其创建一个执行上下文，最后将改函数的执行上下文压入栈中
   2. 执行上下文创建好之后，便进入了函数代码的执行阶段，这里先执行的是d=10的赋值操作，执行语句会将addAll函数执行上下文中的d由undefined变成10
3. 执行add函数调用语句，同样创建执行上下文，并将其压入调用栈

![](I:\myFuture\桌面资料\面试\学习图片\执行add函数时的调用栈.png)

当add函数返回时，该函数的执行上下文会从**栈顶弹出**，并将result的值设置为add函数的返回值

紧接着addAll执行最后一个相加操作并返回会，addAll的执行上下文也会从栈顶部弹出，此时调用栈中只剩下全局上下文了

至此，整个JavaScript流程执行结束了

