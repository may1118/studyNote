# HTTP

[TOC]

## 1. HTTP报文结构

![HTTP报文结构](I:\myFuture\桌面资料\面试\学习图片\HTTP报文结构.png)

## 2. HTTP的请求方法

| 方法    | 作用                                     |
| ------- | ---------------------------------------- |
| GET     | 通常用来获取资源                         |
| POST    | 提交数据，即上传数据                     |
| HEAD    | 获取资源的元信息                         |
| OPTIONS | 列出可对资源实体的请求方法，用于跨域请求 |
| TRACK   | 追踪请求，响应传输路径                   |
| CONNECT | 建立连接通道，用于服务器代理             |
| PUT     | 修改数据                                 |
| DETELE  | 删除资源                                 |

### GET和POST有什么区别

|        | GET       | POST     |
| ------ | --------- | -------- |
| 缓存   | 有缓存    | 无缓存   |
| 编码   | ASCII字符 | 没有限制 |
| 参数   | URL       | 请求体   |
| 幂等性 | 幂等      | 不是     |

**幂等:**执行相同的操作，结果也是相同的

## 3. URI

**URI：**（Uniform Resource Identifier）**统一资源标识符**，作用就是：区分互联网上不同的资源。

但是，它并不是我们常说的**网址**，网址指的是URL，实际上URI包含了URN和URL两个部分，因为URL过于普及，就默认将URI视为URL了。

### URI&URL

URL （Uniform Resource Location），**统一资源定位符**。

URI简单来理解就是**标识/定义了一个资源**，而URL在定义/标识资源的同时**还需要描述如何访问到该资源**。

![](I:\myFuture\桌面资料\面试\学习图片\URL格式.png)

| 名称          | 作用                                                         |
| ------------- | ------------------------------------------------------------ |
| scheme        | 协议名，比如http,https,file...                               |
| user:password | 登录主机时的用户信息，不过不是很安全，不推荐使用，也不常用   |
| host:post     | 主机名和端口号                                               |
| path          | 请求路径，标记资源所在的位置                                 |
| query         | 查询参数，key1=value1&key2=value2                            |
| fragment      | URI所定位资源内的一个**锚点**，**浏览器**可以根据这个锚点跳转到对应的位置 |

例如：

```http
https://www.baidu.com/s?wd=HTTP&rsv_spt=1
```

协议：`HTTPS`

主机和端口：`www.baidu.com` HTTP默认端口80，HTTPS默认端口443

路径：`/s`

查询query：`wd=HTTP&rsv_spt=1`

### URI编码

URI只能使用**ASCII**，除此之外的字符不支持显示，而且还有一部分的界定符，如果不加以处理就会导致解析错误。

因此，URI引入了**编码**机制，将所有非ASCII字符码和界定符转为十六进制字节值，然后在前面加个%

例如，空格被转译成了`%20`

## HTTP状态码

RFC规定HTTP的状态码为三位数，被分为五类：

| 开头 | 作用                                       |
| ---- | ------------------------------------------ |
| 1xx  | 协议处理的中间状态，还需要后续操作         |
| 2xx  | 成功状态                                   |
| 3xx  | 重定向状态，资源位置发生变动，需要重新请求 |
| 4xx  | 报文有误                                   |
| 5xx  | 服务器端发生错误                           |

### 1xx

**100 continue**

**101 Switching Protocols** 在`HTTP`升级为**WebSocket**的时候，如果服务器同意变更，就会发送状态码101

### 2xx

**200 OK** 成功。通常的响应体中放有数据

**204 No Content** 含义与200相同，但响应体后没有body数据

**206 Partial Content** 表示部分内容，它的使用场景为HTTP分块下载和端点续传，当然也会带上响应的请求头字段`Content-Range`

### 3xx

**301 Moved Permanently** 永久重定向

**302 Found** 临时重定向

例如：某个网站从HTTP升级到HTTPS，那么以嵌的站点再也不用了，应当返回`301`，这个时候浏览器会做缓存优化，在第二次访问的时候自动访问重定向的那个地址。

如果只是暂时不可用，那么直接返回`302`即可，浏览器不会做缓存优化。

**304 Not Modified** 当协商缓存命中时会返回这个状态码

### 4xx

**400 Bad Request** 只是笼统地提示一下错误，并不知道哪里出错了

**401 Unauthorized** 由于缺乏莫表资源要求的身份验证凭证，发送的请求未得到满足。

**403 Forbidden** 服务器进制访问，原因有很多，比如：法律禁止、信息敏感

**404 Not Found** 资源未找到，表示没在服务器上找到相应的资源

**405 Method Not Allowed** 请求方法不被服务器端允许

**406 Not Acceptable** 资源无法满足客户端的条件

### 5xx

**500 Internal Server Error** 仅仅告诉服务器出错了，但是不知道具体原因

**501 Not Implemented** 客户端请求的功能还不支持

**502 Bad Gateway** 服务器自身时正常的，但访问的时候出错了，什么错误也不知道

**503 Service Unavailable** 服务器当前很忙，暂时无法相应服务

## HTTP特点 缺点

### HTTP特点

1. **灵活可扩展**
   1. 语义上的自由，只是规定了基本格式
   2. 传输形式的多样性，不仅仅可以传输文本，还能传输图片、视频等任意数据，非常方便
2. **可靠传输**
   1. 基于TCP/IP
3. **请求-应答**
   1. 一发一收 有来有回
4. **无状态**
   1. 通信过程的上下文信息，每次HTTP请求都是独立、无关的，默认不需要保留状态信息。

### HTTP缺点

1. 无状态

   这个无状态是优点还是缺点，需要分场景来看待。

   1. 需要长连接的场景中，需要保存大量的上下文信息，以免传输大量的重复的信息，那么这时候无状态就是HTTP的缺点了
   2. 如果只需要获取一些数据，不需要保存连接的上下文信息，无状态反而减少了网络开销，成为了HTTP的优点。

2. 明文传输

   协议里的报文（头部）不用二进制数据，而是文本形式。

3. 队头阻塞问题

   当HTTP开启长连接时，供用一个TCP连接，同一时刻只能处理一个请求，那么当前请求耗时过长的情况下，**其他的请求只能处于阻塞状态**，也就是著名的队头阻塞问题。

## Accpet系列字段

对于`Accept`系类字段分为四个部分：**数据格式**、**压缩方式**、**支持语言**和**字符集**

### 数据格式

HTTP支持非常多的数据格式，怎么去区分，需要使用到**MIME**（Multipurpose Internet Mail Extensions，**多用途互联网邮件扩展**）。它首先用在邮件系统中，让邮件可以发任意类型的数据，这对HTTP来说也是通用的。

因此，HTTP从**MIME Type**取了一部分来标记报文body部分的数据类型，这些类型体现在`Content-Type`这个字段，当然这是对发送端而言，**接收端**想要收到特定类型的数据，也可以用`Accept`字段。

具体而言，可以分为以下几类：

- text：text/html text/plain text/css
- image：image/gif image/jpeg image/png
- audio/video：audio/mpeg video/mp4
- application：application/json application/javascript application/pdf

### 压缩方式

当然一般这些数据都只会进行编码压缩的，采取什么样的压缩方式体现在了**发送方**的`Content-Encoding`字段上，同样的，接收什么样的压缩方式体现在了**接收方**`Accept-Encoding`字段上。取值：

- gzip：当前最流行的压缩方式
- deflate：另外一种著名的压缩格式
- br：一种专门为HTTP发明的压缩算法

```js
// 发送端
Content-Encoding: gzip
// 接收端
Accept-Encoding: gizp
```



### 支持语言

发送方：`Content-Language`字段

接收方：`Accept-Langeuage`

```js
// 发送端
Content-Language: zh-CN, zh, en
// 接收端
Accept-Language: zh-CN, zh, en
```

### 字符集

发送方并没有对应的`Content-Charset`，而是直接放在了`Content-Type`中

接收方：`Accept-Charset`，指定可以接收的字符集

```js
// 发送端
Content-Type: text/html; charset=utf-8
// 接收端
Accept-Charset: charset=utf-8
```

![](I:\myFuture\桌面资料\面试\学习图片\Accept字段.png)

## 7. 定长和不定长的数据，HTTP如何传输

### 定长包体

对于定长包体而言，服务端在传输的时候一定会带上`Content-Length`，来指明包体的长度

如果Content-Length的长度小于实际长度，会截取多处内容，如果小于实际长度，就无法显示

### 不定长包体

对于不定长的包体，需要使用到另外一个HTTP头部字段了：

```http
Transfer-Encoding: chunked
```

表示分块传输数据，设置了这个字段后会自动产生两个效果：

- Content-Length字段会被忽略
- 基于长连接持续推送动态内容

## 8. 处理大文件的传输

对于非常大的文件，如果要一口气全部传输过来显然是不现实的，会有大量的等待时间，严重影响用户体验。因此，HTTP针对这一场景，采取了**范围请求**的解决方案，允许客户端仅仅请求一个资源的一部分。

### 范围请求

需要添加的响应头

```http
Accept-Ranges: none
```

用来告知客户端这边是支持范围请求的

### Range字段拆解

对于客户端而言，它需要指定请求哪一部分，通过`Range`这个请求字段确认，格式为`bytes=x-y`。书写格式

- 0-499表示从开始到499个字节
- 500- 表示从第500字节到文件的终点
- -100 表示最后100个字节

服务端接收请求之后，首先验证范围是否合法，如果越界了那么返回416错误码，否则返回206状态码

同时，服务器需要添加`Content-Range`字段，这个字段格式根据请求头中`Range`字段的不同而有所差异。

## 提交表单数据

主要有两种表单的提交方式，提现在两种不同的`Content-Type`取值：

- application/x-www-form-urlencoded
- multipart/form-data

由于表单一般是`post`请求，很少考虑`GET`，因此默认将提交的数据放到请求体中

### application/x-www-form-urlencoded

对于`application/x-www-form-urlencoded`格式的表单内容，有以下特点：

- 其中的数据会被编码成**&**分隔的键值对
- 字符对**URL编码方式**编码

### multiparty/form-data

对于`multipart/form-data`而言：

- 请求头中的`Content-Type`字段会包含`boundary`，且`boundary`的值浏览器默认指定。例如：`Content-Type:multipart/form-data;boundary===---`
- 数据会分为多个部分，每两个部分之间通过分隔符来分割，每部分表述均有HTTP头部描述子包体，如`Content-Type`，在最后的分隔符会加上`--`表示结束

### 小结

`multipart/form-data`格式最大的特点在于，每一个表单元素都是独立的资源表述。有时候感觉不到`boundary`的存在，因为浏览器和HTTP进行了一系列操作

而且，在实际场景中，对于图片等文件的上传，基本采用`multipart/form-data`而不用`application/x-www-form-urlencoded`，因为没有必要做URL编码，带来巨大耗时的同时也占用了更多的空间

## 10. HTTP1.1如何解决HTTP的队头阻塞问题

### 什么是队头阻塞

HTTP传输是基于**请求-应答**的模式进行的，报文必须是一发一收，但是，里面的任务被放在一个任务队列中**串行执行**，一旦队首的请求处理太慢，就会阻塞后面请求的处理。

### 并发连接

对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队列任务阻塞其他所分配所有任务。规定过客户端最多并发2个连接，不过事实上现在的浏览器标准中，这个上线要多很多，Chrome中式6个。

但其实，即使是提高并发连接，还是不能满足人们对想能的需求。

### 域名分片

浏览器对域名并发连接有限制，那么我们可以多分几个域名。

例如：a.domain.com b.domain.com

这样在domain.com域名下可以分出非常多的二级域名，而他们都指向同样一台服务器，能够并发的连接数更多了，事实上也更好解决了队头阻塞问题。

## 11. cookie

### cookie简介

因为HTTP式无状态协议，每次请求都是独立、无关的，默认不需要保留状态信息。但是有时候需要保存一些状态，就可以使用Cookie。

Cookie的本质就是浏览器里面存储的一个很小的文本文件，内部以键值对的方式来存储

```http
// 请求头
Cookie: a=xxx;b=xxx
// 响应头
Set-Cookie: a=xxx
set-Cookie: b=xxx
```

### cookie属性

#### 生存周期

cookie的有效期可以通过**Expires**和**Max-age**两个属性来设置

- Expires：过期时间
- Max-age：用的是一段时间间隔，单位是秒，从浏览器收到报文开始计算

若cookie过期，则这个cookie会被删除，并不会发送给服务端

#### 作用域

关于作用域有两个属性：**Domain**和**path**

给cookie绑定了域名和路径，在发送请求之前，发现域名或者路径和这两个属性不匹配，那么就不会带上cookie。

#### 安全

如果带上**secure**，说明只能通过`HTTPS`传输cookie

如果cookie字段上带上了**HttpOnly**，那么说明只能通过HTTP协议传输，不能通过JavaScript访问，这也是预防XSS攻击的重要手段。

相应的，对于CSRF攻击的预防，有**SameSite**属性

**SameSite**可以设置为三个值，**Strict** **Lax** 和 **None**

- Strict，浏览器完全禁止第三方请求携带cookie，只能在同域名下才能携带，其他网站不可以
- Lax，只能在**GET方法提交表单**，或者**a标签发送get请求**的情况下可以携带
- None，默认模式，请求会自动携带上Cookie

### 缺点

- 容量缺陷。cookie的体积上线只有4KB，只能用来存储少量的信息。
- 性能缺陷。cookie紧跟域名，不管域名下面的某一个地址需不需要这个cookie，请求都会携带上完整的cookie，这样随着请求数的增多，其实会造成巨大的性能浪费，因为请求携带了很多不必要的内容。**但是可以通过domain和path指定作用域来解决**。
- 安全缺陷。由于cookie以纯文本的形式在浏览器和服务器中传递，很容易被非法用户截获，然后进行一系列的篡改，在cookie的有效期内重新发送给服务器，这样是相仿危险的。另外，在HttpOnly为false的情况下，cookie信息能直接通过JavaScript脚本来读取

## 12. HTTP代理

引入代理，作为代理的服务器，相当于一个中间人的角色，相对于客户端而言，表现为服务器进行相应；相对于源服务器，表现为客户端发起请求，具有**双重身份**

### 功能

- **负载均衡**：客户端的请求只会先到达代理服务器，后面到底有多少源服务器，IP都是多少，客户端是不知道的。因此，这个代理服务器拿到这个请求之后，可以通过特定的算法发送给不同的源服务器，让各台源服务器的负载经量均衡
- **保障安全**
  - 利用心跳机制监控后台的服务器，一旦发现了故障机就将其踢出集群。并且对于上下行的数据进行过滤，对非法IP限流，这些都是代理服务器的工作
- **缓存代理**
  - 将内容缓存到代理服务器，使得客户端可以直接从代理服务器获得而不用到源服务器那里。

### 相关头部字段

#### Via

代理服务器需要表明自己的身份，在HTTP传输中留下自己的痕迹，可以通过`Via`字段来记录。

例如：需要通过两台代理服务器，在客户端发送请求后会经历

> 客户端 -> 代理1 -> 代理2 -> 源服务器

源服务器收到请求后，会在**请求头**拿到这个字段

```http
Via: proxy_server1,proxy_server2
```

而源服务器响应时，最终在客户端会拿到这样的**响应头**：

```http
Via: proxy_server2,proxy_server1
```

可以看到，**Via**中代理的顺序即为在HTTP传输中报文传达的顺序。

#### X-Forwarded-For

**为谁转发**，它记录的**请求方**的IP地址

#### X-Real-IP

获取用户真实的IP的字段，不管中间经过多少代理，这个字段使用记录最初的客户端IP

## 13. 缓存及缓存代理

### 缓存过程

首先通过`Cache-Control`验证强缓存是否可用

- 如果强缓存可用，直接使用
- 否则进入协商缓存，即发送HTTP请求，服务器通过请求头中的`If-Modified-Since`和`If-None-Match`这些条件请求字段检查资源是否更新
  - 若更新，返回资源和200状态码
  - 否则，返回304，告诉浏览器直接从缓存获取资源

### 代理缓存

对于源服务器来说，它也是有缓存的。比如：**Redis**、**Memcache**，但对于HTTP缓存来说，如果每次客户端缓存都失效要到源服务器获取，那给原服务器的压力时很大的。

由此引入了**缓存代理**的机制。让**代理服务器**接管一部分的服务器HTTP缓存，客户端缓存过期后**就近**到缓存中获取，代理缓存过期了才请求源服务器，这样流量巨大时后能明显降低源服务器的压力。

#### 源服务器的缓存控制

- public和private

  - 在源服务器的响应头中，会加上`Cache-Control`这个字段进行缓存控制字段，那么它的值可以加入**private**或者**public**，表示是否允许代理服务器缓存，前者禁止，后者为允许

    对于一些非常私密的数据，如果缓存到代理服务器，别人直接访问代理就可以拿到这些数据，是非常危险的，因此，对于这些数据一般是不允许代理服务器进行缓存的，可以将响应头的`Cache-control`设为**private**

- proxy-revalidate

  - `must-revalidate`的意思是**客户端**缓存过期就去源服务器获取，而`proxy-revalidate`则表示**代理服务器**过期后就到源服务器获取。

- s-maxage

  - s --> `share`，限定了缓存在代理服务器中可以存放多久，和限制客户端缓存时间的**max-age**并不冲突

```http
Cache-Control: public,max-age=1000,s-maxage=2000
```

相当于源服务器说：这个响应允许代理服务器缓存，服务器缓存过期了到代理服务器中拿，并且客户端的缓存时间为1000s，在代理服务器缓存的时间为2000s

### 客户端缓存的控制

#### max-state和min-fresh

在客户端的请求头中，可以加入这两个字段，来对代理服务器上的缓存进行宽容和限制操作

```http
max-state: 100
```

表示：客户端到代理服务器上拿缓存的时候，即使代理缓存过期了也不要紧，只要过期时间在**100s之内**，还是可以从代理中获取。

```http
min-fresh: 100
```

表示代理缓存需要一定的新鲜度，不要等到缓存刚好到期再拿，**一定要在到期前100s之前拿**，否则拿不到

#### only-if-cached

这个字段加上后表示客户端**只会接收代理缓存**，而不会接收源服务器的响应，如果代理无效，则直接返回**504**（Gateway Timeout）

## 14. 跨域

### 同源策略

协议 主机 端口都相同则为同源，否则是非同源。非同源站点有这样一些限制：

- 不能读取和修改对方的DOM
- 不能读取对方的cookie、IndexDB、Localstorage
- 限制XMLHttpRequest请求

当浏览器向不表URL发送Ajax请求时，只要当前URL和目标URL不同源，则产生跨域，被成为**跨域请求**

跨域请求的响应一般会被**浏览所拦截**

解决方案

### CORS跨域

跨站资源共享

### JSONP跨域

**script**标签

### Nginx

**Nginx**是一种高性能的**反向代理**服务器，可以轻松解决跨域问题。

![](I:\myFuture\桌面资料\面试\学习图片\Nginx代理.png)

**正向代理**帮助客户端访问客户端自己访问不到的服务器，然后将结果返回给客户端

**反向代理**拿到客户端的请求，将请求转发给其他的服务器，主要的场景是维持服务器集群的**负载均衡**，换句话说，反向代理**帮助其他服务器拿到请求**，然后选择在一个贺实的服务器上，将请求转交给它。

**区别**：

- 正向代理服务器帮助客户端做事情
- 反向代理服务器帮助其他的服务器做事情

Nginx用于反向代理：

```http
server {
  listen  80;
  server_name  client.com;
  location /api {
    proxy_pass server.com;
  }
}
```

Nginx相当于起了一个跳板机，这个跳板机的域名就是client.com，让客户端首先访问client.com/api，这当然没有跨域，然后Nginx服务端作为反向代理，将请求发送给sever.com，当响应返回时又将响应给到客户端，这就是整个跨域请求的过程。

其实还有**postMessage** **WebSocket.**..

## 15. SSL/TLS握手过程

```js
HTTPS = HTTP + SSL/TLS
```

HTTPS并不是一个新的协议，而是在HTTP下面增加了一层SSL/TLS协议

### SSL/TLS

**SSL**（Secure Sockets Layer），在OSI七层模型中处于会话层（第5层）。之前SSL出过三个大版本，当它发展到第三个版本的时候才被标准化，成为**TLS**（传输层安全，Transport Layer Security），并被当作TLS1.0的版本，准确的说，**TLS1.0 = SSL3.1**

（具体还是不懂，再看看阮一峰老师的博客吧）

## 16. HTTP/2有那些改进

对于性能提升：

- 头部压缩
- 多路复用
- 二进制传输

颠覆性功能：

- 设置请求优先级
- 服务器推送

### 头部压缩

在HTTP1.1及之前的时代，**请求体**一般会有响应的压缩编码过程，通过`Content-Encoding`头部字段来指定，但头部字段本身的压缩呢？

当请求字段非常复杂的时候，尤其对于GET请求，请求报文报文几乎请求头，这个时候还是存在非常大的优化空间的。HTTP/2针对头部字段，也采用了对应的压缩算法——HPACK，对请求头进行压缩。

**HPACK亮点**：

- 在服务器和客户端之间建立哈希表，将用到的字段存在这张表中，那么在传输的时候对于之前出现过的值，只要把**索引**传给对方即可，对方拿到了索引查表就行了。这样传索引的方式，可以说方请求头字段极大程度的精简和复用。

  ![](I:\myFuture\桌面资料\面试\学习图片\HPACK索引表.png)

- 对于整数和字符串进行**哈夫曼编码**，哈夫曼编码的原理就是将所有出现的字符建立一张索引表，然后让出现次数多的字符对应的索引尽可能短，传输的时候也是传输这样的**索引序列**，可以达到非常高的压缩率

### 多路复用

### HTTP队头阻塞

**原因**：HTTP基于请求-响应的模型，在同一个TCP长连接中，前面的请求没有得到响应，后面的请求就会被阻塞。

在HTTP/1.1中，可以使用**并发连接**和**域名分片**的方式解决这个问题，但这并没有真正从HTTP本身层面解决问题，只是增加了TCP连接，分摊风险而已。而且这么做也有弊端，多条TCP连接会竞争有限的带宽，让真正优先级高的请求不能优先处理。

而HTTP/2便从HTTP协议本身解决了**队头阻塞**问题。注意，这里并不是指的TCP队头阻塞，而是**HTTP队头阻塞**。TCP的队头阻塞是在数据包层面，单位是数据包，前一个报文没有收到便不会将后面的报文传给HTTP，而HTTP的队头阻塞是在HTTP请求-响应层面，前一个请求没处理完，后面的请求就要阻塞。两者所在的蹭面是不一样的。

#### 二进制分帧

首先，HTTP/2认为明文传输对及其而言太麻烦了，不方便计算机的解析，因为对于文本而言会有多义的字符，比如回车换行到底是内容还是分隔符，在内部需要用到状态机去识别，效率比较低。于是HTTP/2感觉把报文全部换成二进制格式，全部传输01串，方便了及其的解析。

原来`Headers+Body`的报文格式如今被拆分成了一个个二进制的帧，用`Headers`帧存放头部字段，`Data帧`存放请求体数据。分帧之后，服务器看到的不再是一个个完整的HTTP请求报文，而是**一堆乱序的二进制帧**。这些二进制帧不存在先后关系，因此也就不会排队等待，也没有了HTTP的队头阻塞问题。

通信双方都可以给对方发送二进制帧，这种二进制帧的双向传输的序列，也叫做**流（Stream）**。HTTP/2用流来在一个TCP连接上进行多个数据帧的通信，这就是**多路复用**

**二进制帧是乱序的**

但是，所谓的乱序，指的是不同ID的Stream是乱序的，同一个Stream ID的帧一定是顺序传输的。二进制帧到达后对方会将Stream ID相同的二进制帧进行组装，变成完整的**请求报文**和**响应报文**。当然，在二进制帧当中还有一些其他字段，实现了**优先级**和**流量控制**。

### 服务器推送

服务器已经不再是完全被动地接收请求，响应请求，他也能新建stream来给客户端发送消息，当TCP连接建立后，比如浏览器请求一个HTML文件，服务器就可以返回HTML的基础上，将HTML中引用到的其他资源文件一起返回给客户端，减少客户端的等待。

## 总结

当然，HTTP/2新增了那么多特性，HTTP/2完全兼容之前的HTTP的语法和语义，如请求头 URL 状态码 头部字段都没有改变

同时HTTP也支持TLS，并且现在主流的浏览器都公开支持HTTP/2，因此现在看到的HTTP/2也基本都是泡在TLS上面的。

![](I:\myFuture\桌面资料\面试\学习图片\HTTP迭代.png)

## 16. HTTP/2中的二进制帧

### 帧结构

![](I:\myFuture\桌面资料\面试\学习图片\帧结构.png)

每个帧分为**帧头**和**帧体**。

帧类型可以分为**数据帧**和**控制帧**两种。数据帧用来存放HTTP报文，控制帧用来管理流的传输。

**帧标志**，里面一共有 8 个标志位，常用的有 **END_HEADERS**表示头数据结束，**END_STREAM**表示单方向数据发送结束。

最后4个字节`Stream ID`，也就是**流标识符**，有了它，接收方就能从乱序的二进制帧中选出ID相同的帧，按顺序组装成请求/响应报文。

### 流的状态变化

HTTP/2其实也是借鉴TCP状态变化的思想，根据帧的标志位实现具体的状态改变。

![](I:\myFuture\桌面资料\面试\学习图片\HTTP-2流的状态变化.png)

最开始两者都是空闲状态，当客户端发送**Header帧**后，开始分配`Stream ID`，此时客户端的流打开，服务端接收之后服务端的流也打开，两端的流都打开之后，就可以互相传递数据帧和控制帧了。

当客户端要关闭时，向服务端发送`SEND_STREAM`帧，进入半关闭状态，这个时候客户端只能接收数据，而不能发送数据。

服务端收到`END_STREAM`帧后也进入了半关闭状态，不过此时服务端的情况只能发送数据，而不能接收数据。随后服务端也向客户端发送`END_STREAM`帧，表示数据发送完毕，双方进入关闭状态。

如果下次要开启新的`流`，流 ID 需要自增，直到上限为止，到达上限后开一个新的 TCP 连接重头开始计数。由于流 ID 字段长度为 4 个字节，最高位又被保留，因此范围是 0 ~ 2的 31 次方，大约 21 亿个。

### 流的特性

- 并发性。一个HTTP/2连接上可以同时发多个帧，这一点和HTTP/1不同。这也是**多路复用**的基础
- 自增性：流ID时不可重用的，而是会按序递增，达到上线之后又新开TCP连接从头开始。
- 双向性：客户端和服务端都可以创建流，互不干扰，双方都可以作为发送者或接收方
- 可设置优先级：可以设置数据帧的优先级，让服务器先处理重要资源，优化用户体验。